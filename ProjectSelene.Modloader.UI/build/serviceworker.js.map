{
  "version": 3,
  "sources": ["../../ProjectSelene.Modloader/src/communication/serviceworker-sw.ts", "../../ProjectSelene.Modloader/src/communication/single.ts", "../../node_modules/idb-keyval/dist/index.js", "../../ProjectSelene.Modloader/src/serviceworker/sw-clients.ts", "../../ProjectSelene.Modloader/src/serviceworker/serviceworker.ts"],
  "sourcesContent": ["\r\ndeclare const self: ServiceWorkerGlobalScope;\r\n\r\nexport class ServiceWorkerCommunication {\r\n\tprivate nextId = 1;\r\n\tprivate readonly messageQueue = new Map<\r\n\t\tnumber,\r\n\t\t{\r\n\t\t\tcount: number;\r\n\t\t\tresults: unknown[];\r\n\t\t\tsuccess: boolean;\r\n\t\t\tresolve: (arg: unknown[] | unknown) => void;\r\n\t\t\treject: (arg: unknown[] | unknown) => void;\r\n\t\t}\r\n\t>();\r\n\tconstructor() {\r\n\t\tself.onmessage = () => void 0; //Does nothing but is required for it to work\r\n\t\tself.addEventListener('message', event => {\r\n\t\t\tif (event.origin !== location.origin) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tthis.handleCallback(event.data);\r\n\t\t});\r\n\t}\r\n\r\n\tprivate handleCallback(data: { id: number; success: boolean; data: unknown; }) {\r\n\t\tconst queue = this.messageQueue.get(data.id);\r\n\t\tif (queue && data.success !== undefined) {\r\n\t\t\tqueue.count--;\r\n\t\t\tqueue.results.push(data.data);\r\n\t\t\tif (!data.success) {\r\n\t\t\t\tqueue.success = false;\r\n\t\t\t}\r\n\t\t\tif (queue.count <= 0) {\r\n\t\t\t\tif (data.success) {\r\n\t\t\t\t\tqueue.resolve(queue.results);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tqueue.reject(queue.results);\r\n\t\t\t\t}\r\n\t\t\t\tthis.messageQueue.delete(data.id);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\ton<T>(type: string, handle: (arg: T, sourceId: string) => unknown | PromiseLike<unknown>) {\r\n\t\tself.addEventListener('message', event => {\r\n\t\t\tif (event.origin !== location.origin) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (!(event.source instanceof Client)) {\r\n\t\t\t\tevent.source?.postMessage({\r\n\t\t\t\t\tid: event.data?.id,\r\n\t\t\t\t\tsuccess: false,\r\n\t\t\t\t\tdata: {\r\n\t\t\t\t\t\tsourceId: (event?.source as unknown as { id?: string })?.id,\r\n\t\t\t\t\t\tmessage: 'Can only process messages from clients',\r\n\t\t\t\t\t},\r\n\t\t\t\t});\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tconst data = event.data as { id: number; type: string; data: unknown };\r\n\t\t\tif (data.type === type) {\r\n\t\t\t\tevent.waitUntil(\r\n\t\t\t\t\tPromise.resolve()\r\n\t\t\t\t\t\t.then(() => handle(data.data as T, event.source instanceof Client ? event.source.id + '' : ''))\r\n\t\t\t\t\t\t.then(result =>\r\n\t\t\t\t\t\t\tevent.source?.postMessage({\r\n\t\t\t\t\t\t\t\tid: data.id,\r\n\t\t\t\t\t\t\t\tsuccess: true,\r\n\t\t\t\t\t\t\t\tdata: result,\r\n\t\t\t\t\t\t\t}),\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t.catch(result =>\r\n\t\t\t\t\t\t\tevent.source?.postMessage({\r\n\t\t\t\t\t\t\t\tid: data.id,\r\n\t\t\t\t\t\t\t\tsuccess: false,\r\n\t\t\t\t\t\t\t\tdata: result,\r\n\t\t\t\t\t\t\t}),\r\n\t\t\t\t\t\t),\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tsendToClients<T>(type: string, message: unknown, clientIds: string[], maxDelay = 300) {\r\n\t\tconst id = this.nextId++;\r\n\t\tconst cIds = new Set(clientIds);\r\n\t\treturn Promise.race([self.clients\r\n\t\t\t.matchAll({\r\n\t\t\t\ttype: 'window',\r\n\t\t\t})\r\n\t\t\t.then(clients => {\r\n\t\t\t\tclients = clients.filter(c => cIds.has(c.id));\r\n\t\t\t\tif (clients.length === 0) {\r\n\t\t\t\t\treturn [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn this.internalSendToClients<T>(id, clients, type, message);\r\n\t\t\t}), this.deleteAfterDelay<T>(id, maxDelay)]);\r\n\t}\r\n\r\n\tprivate internalSendToClients<T>(id: number, clients: readonly WindowClient[], type: string, message: unknown) {\r\n\t\treturn new Promise<T[]>((resolve, reject) => {\r\n\t\t\tthis.messageQueue.set(id, {\r\n\t\t\t\tcount: clients.length,\r\n\t\t\t\tresults: [],\r\n\t\t\t\tsuccess: true,\r\n\t\t\t\tresolve: resolve as (arg: unknown[] | unknown) => void,\r\n\t\t\t\treject,\r\n\t\t\t});\r\n\r\n\t\t\tfor (const client of clients) {\r\n\t\t\t\tclient.postMessage({\r\n\t\t\t\t\tid,\r\n\t\t\t\t\tdata: message,\r\n\t\t\t\t\ttype,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tprivate deleteAfterDelay<T>(id: number, delay: number) {\r\n\t\treturn new Promise<T[]>((_, reject) => {\r\n\t\t\tsetTimeout(() => {\r\n\t\t\t\tthis.messageQueue.delete(id);\r\n\t\t\t\tconsole.error(`Failed to receive response after ${delay} ms`);\r\n\t\t\t\treject(new Error('Timeout'));\r\n\t\t\t}, delay);\r\n\t\t})\r\n\t}\r\n}\r\n", "export class SingleCommunication {\r\n\tprivate readonly resolveQueue = new Map<number, (arg: unknown) => void>();\r\n\tprivate readonly rejectQueue = new Map<number, (arg: unknown) => void>();\r\n\r\n\tconstructor(private readonly messagePort: MessagePort) {\r\n\t\tthis.messagePort.onmessage = () => void 0; //Does nothing but is required for it to work\r\n\t\tthis.messagePort.addEventListener('message', event => {\r\n\t\t\tconst data = event.data as {\r\n\t\t\t\tid: number;\r\n\t\t\t\tsuccess: boolean;\r\n\t\t\t\tdata: unknown;\r\n\t\t\t};\r\n\t\t\tif (data.success) {\r\n\t\t\t\tthis.resolveQueue.get(data.id)?.(data.data);\r\n\t\t\t} else {\r\n\t\t\t\tthis.rejectQueue.get(data.id)?.(data.data);\r\n\t\t\t}\r\n\t\t\tthis.resolveQueue.delete(data.id);\r\n\t\t\tthis.rejectQueue.delete(data.id);\r\n\t\t});\r\n\t}\r\n\r\n\tsend<T>(type: string, message: unknown, ...transferables: unknown[]) {\r\n\t\treturn new Promise<T>((resolve, reject) => {\r\n\t\t\tconst id = Math.random() * 1000000 + Math.random();\r\n\t\t\tthis.resolveQueue.set(id, resolve as (arg: unknown) => void);\r\n\t\t\tthis.rejectQueue.set(id, reject);\r\n\r\n\t\t\tthis.messagePort.postMessage(\r\n\t\t\t\t{\r\n\t\t\t\t\tid,\r\n\t\t\t\t\tdata: message,\r\n\t\t\t\t\ttype,\r\n\t\t\t\t},\r\n\t\t\t\ttransferables.filter(t => t) as Transferable[],\r\n\t\t\t);\r\n\t\t});\r\n\t}\r\n\r\n\ton<T>(type: string, handle: (arg: T) => unknown | PromiseLike<unknown>) {\r\n\t\tthis.messagePort.addEventListener('message', event => {\r\n\t\t\tconst data = event.data as { id: number; type: string; data: unknown };\r\n\t\t\tif (data.type === type) {\r\n\t\t\t\tPromise.resolve()\r\n\t\t\t\t\t.then(() => handle(data.data as T))\r\n\t\t\t\t\t.then(result =>\r\n\t\t\t\t\t\tthis.messagePort.postMessage({\r\n\t\t\t\t\t\t\tid: data.id,\r\n\t\t\t\t\t\t\tsuccess: true,\r\n\t\t\t\t\t\t\tdata: result,\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t)\r\n\t\t\t\t\t.catch(result =>\r\n\t\t\t\t\t\tthis.messagePort.postMessage({\r\n\t\t\t\t\t\t\tid: data.id,\r\n\t\t\t\t\t\t\tsuccess: false,\r\n\t\t\t\t\t\t\tdata: result,\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n", "function promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n        // @ts-ignore - file size hacks\n        request.oncomplete = request.onsuccess = () => resolve(request.result);\n        // @ts-ignore - file size hacks\n        request.onabort = request.onerror = () => reject(request.error);\n    });\n}\nfunction createStore(dbName, storeName) {\n    let dbp;\n    const getDB = () => {\n        if (dbp)\n            return dbp;\n        const request = indexedDB.open(dbName);\n        request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n        dbp = promisifyRequest(request);\n        dbp.then((db) => {\n            // It seems like Safari sometimes likes to just close the connection.\n            // It's supposed to fire this event when that happens. Let's hope it does!\n            db.onclose = () => (dbp = undefined);\n        }, () => { });\n        return dbp;\n    };\n    return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));\n}\nlet defaultGetStoreFunc;\nfunction defaultGetStore() {\n    if (!defaultGetStoreFunc) {\n        defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n    }\n    return defaultGetStoreFunc;\n}\n/**\n * Get a value by its key.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction get(key, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => promisifyRequest(store.get(key)));\n}\n/**\n * Set a value with a key.\n *\n * @param key\n * @param value\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction set(key, value, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.put(value, key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic \u2013 if one of the pairs can't be added, none will be added.\n *\n * @param entries Array of entries, where each entry is an array of `[key, value]`.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction setMany(entries, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        entries.forEach((entry) => store.put(entry[1], entry[0]));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Get multiple values by their keys\n *\n * @param keys\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction getMany(keys, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => Promise.all(keys.map((key) => promisifyRequest(store.get(key)))));\n}\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n * @param key\n * @param updater A callback that takes the old value and returns a new value.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction update(key, updater, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => \n    // Need to create the promise manually.\n    // If I try to chain promises, the transaction closes in browsers\n    // that use a promise polyfill (IE10/11).\n    new Promise((resolve, reject) => {\n        store.get(key).onsuccess = function () {\n            try {\n                store.put(updater(this.result), key);\n                resolve(promisifyRequest(store.transaction));\n            }\n            catch (err) {\n                reject(err);\n            }\n        };\n    }));\n}\n/**\n * Delete a particular key from the store.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction del(key, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.delete(key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Delete multiple keys at once.\n *\n * @param keys List of keys to delete.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction delMany(keys, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        keys.forEach((key) => store.delete(key));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Clear all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction clear(customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.clear();\n        return promisifyRequest(store.transaction);\n    });\n}\nfunction eachCursor(store, callback) {\n    store.openCursor().onsuccess = function () {\n        if (!this.result)\n            return;\n        callback(this.result);\n        this.result.continue();\n    };\n    return promisifyRequest(store.transaction);\n}\n/**\n * Get all keys in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction keys(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAllKeys) {\n            return promisifyRequest(store.getAllKeys());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);\n    });\n}\n/**\n * Get all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction values(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAll) {\n            return promisifyRequest(store.getAll());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.value)).then(() => items);\n    });\n}\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction entries(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        // (although, hopefully we'll get a simpler path some day)\n        if (store.getAll && store.getAllKeys) {\n            return Promise.all([\n                promisifyRequest(store.getAllKeys()),\n                promisifyRequest(store.getAll()),\n            ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]));\n        }\n        const items = [];\n        return customStore('readonly', (store) => eachCursor(store, (cursor) => items.push([cursor.key, cursor.value])).then(() => items));\n    });\n}\n\nexport { clear, createStore, del, delMany, entries, get, getMany, keys, promisifyRequest, set, setMany, update, values };\n", "import * as idb from 'idb-keyval';\r\n\r\nconst store = idb.createStore('SeleneDb-sw-cache', 'sw-cache');\r\n\r\ndeclare const self: ServiceWorkerGlobalScope;\r\n\r\nexport class ServiceWorkerClients {\r\n    private clients: string[] = [];\r\n\r\n    public async load() {\r\n        this.clients = ((await idb.get('clients', store)) as string[]) ?? [];\r\n        await this.removeInactiveClients();\r\n    }\r\n\r\n    public async removeInactiveClients() {\r\n        const ids = (await self.clients.matchAll({ type: 'window' }))\r\n            .filter(c => this.clients.includes(c.id))\r\n            .map(c => c.id)\r\n            .sort();\r\n\r\n        await idb.set('clients', ids, store);\r\n        this.clients = ids;\r\n    }\r\n\r\n    public getClients() {\r\n        return this.clients;\r\n    }\r\n\r\n\r\n    public async addClient(id: string) {\r\n        this.clients.push(id);\r\n        this.clients.sort();\r\n        await idb.set('clients', this.clients, store);\r\n    }\r\n}", "import { ServiceWorkerCommunication } from '../communication/serviceworker-sw';\r\nimport { SingleCommunication } from '../communication/single';\r\nimport { ServiceWorkerClients } from './sw-clients';\r\n\r\n// export empty type because of tsc --isolatedModules flag\r\nexport type { };\r\n\r\ndeclare const self: ServiceWorkerGlobalScope;\r\n\r\ninterface WorkerRegistration {\r\n\tworkers: SingleCommunication[];\r\n\tlastWorker: number;\r\n}\r\nconst workers = new Map<string, WorkerRegistration>();\r\n\r\nconst swClients = new ServiceWorkerClients();\r\n\r\nconst coms = new ServiceWorkerCommunication();\r\ncoms.on('workers', async (worker: MessagePort[], id) => {\r\n\tworkers.set(id, {\r\n\t\tlastWorker: 0,\r\n\t\tworkers: worker.map(port => new SingleCommunication(port))\r\n\t});\r\n\r\n\tawait swClients.addClient(id);\r\n});\r\n\r\nself.addEventListener('install', (event) => {\r\n\tif ('addRoutes' in event) {\r\n\t\t// @ts-expect-error There are no types for addRoutes yet\r\n\t\tevent.addRoutes([\r\n\t\t\t{\r\n\t\t\t\tcondition: { urlPattern: 'http://localhost:8182/*' },\r\n\t\t\t\tsource: 'network',\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tcondition: { urlPattern: 'http://127.0.0.1:8182/*' },\r\n\t\t\t\tsource: 'network',\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tcondition: { urlPattern: self.origin + '/api/*' },\r\n\t\t\t\tsource: 'race-network-and-fetch-handler',\r\n\t\t\t},\r\n\t\t]);\r\n\t}\r\n\tself.skipWaiting();\r\n\treturn event.waitUntil(\r\n\t\tcaches\r\n\t\t\t.open('selene-loader')\r\n\t\t\t.then(cache => cache.add('static/js/prefix.js'))\r\n\t\t\t.catch(() => {\r\n\t\t\t\t/* Ignore error that happens if we are local - we don't need a cache for local */\r\n\t\t\t})\r\n\t);\r\n},\r\n);\r\n\r\nasync function install() {\r\n\tawait swClients.load();\r\n\tawait coms.sendToClients('install', {}, swClients.getClients(), 300);\r\n}\r\nconst installed = install().catch(err => console.error(err));\r\n\r\nself.addEventListener('activate', () => self.clients.claim());\r\n\r\nself.addEventListener('fetch', event =>\r\n\tevent.respondWith(\r\n\t\tinstalled.then(() => {\r\n\t\t\tif (event.request.headers.get('Accept') === 'text/event-stream') {\r\n\t\t\t\treturn fetch(event.request);\r\n\t\t\t}\r\n\r\n\t\t\tconst reg = workers.get(event.clientId);\r\n\t\t\tif (!reg) {\r\n\t\t\t\treturn fromNetworkOrCached(event.request);\r\n\t\t\t}\r\n\r\n\t\t\treturn sendToWorker(event, reg);\r\n\t\t})\r\n\t),\r\n);\r\n\r\nasync function sendToWorker(event: FetchEvent, reg: WorkerRegistration) {\r\n\tconst next = ((reg.lastWorker ?? 0) + 1) % reg.workers.length;\r\n\tconst worker = reg.workers[next];\r\n\treg.lastWorker = next;\r\n\r\n\tconst stream = new TransformStream();\r\n\r\n\tlet body: ReadableStream<Uint8Array> | null = event.request.body;\r\n\tif ((event.request.method === 'POST' || event.request.method === 'PUT') && !body) {\r\n\t\t//Firefox doesn't support body so just read everything and turn it into a stream\r\n\t\tconst tstream = new TransformStream();\r\n\t\tbody = tstream.readable;\r\n\r\n\t\tconst writer = tstream.writable.getWriter();\r\n\r\n\t\tevent.request\r\n\t\t\t.arrayBuffer()\r\n\t\t\t.then(buffer => {\r\n\t\t\t\twriter.write(new Uint8Array(buffer));\r\n\t\t\t\twriter.close();\r\n\t\t\t})\r\n\t\t\t.catch(() => writer.abort());\r\n\t}\r\n\r\n\tconst response = worker.send(\r\n\t\t'fetch',\r\n\t\t{\r\n\t\t\trequest: {\r\n\t\t\t\tmethod: event.request.method,\r\n\t\t\t\turl: event.request.url,\r\n\t\t\t\theaders: toObject(event.request.headers),\r\n\t\t\t\tbody,\r\n\t\t\t\tclientId: event.clientId,\r\n\t\t\t},\r\n\t\t\tresponse: stream.writable,\r\n\t\t},\r\n\t\tstream.writable,\r\n\t\tbody,\r\n\t) as Promise<ResponseInit>;\r\n\r\n\treturn new Response(stream.readable, await response);\r\n}\r\n\r\nasync function fromNetworkOrCached(request: Request) {\r\n\tif (request.url.startsWith('chrome-extension') || request.method !== 'GET') {\r\n\t\treturn fetch(request);\r\n\t}\r\n\r\n\tif (!navigator.onLine) {\r\n\t\tconst cached = await caches.match(request);\r\n\t\tif (cached) {\r\n\t\t\treturn cached;\r\n\t\t}\r\n\t}\r\n\r\n\ttry {\r\n\t\tconst response = await fetch(request);\r\n\r\n\t\tconst cache = await caches.open('selene-loader');\r\n\t\tawait cache.put(request, response.clone());\r\n\r\n\t\treturn response;\r\n\t} catch {\r\n\t\tconst cached = await caches.match(request);\r\n\t\tif (cached) {\r\n\t\t\treturn cached;\r\n\t\t}\r\n\r\n\t\treturn new Response('Network error happened', {\r\n\t\t\tstatus: 408,\r\n\t\t\theaders: { 'Content-Type': 'text/plain' },\r\n\t\t});\r\n\t}\r\n}\r\n\r\nfunction toObject(headers: Headers) {\r\n\tconst result: Record<string, string> = {};\r\n\theaders.forEach((value, key) => (result[key] = value));\r\n\treturn result;\r\n}\r\n"],
  "mappings": "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",
  "names": ["ServiceWorkerCommunication", "event", "data", "queue", "type", "handle", "_a", "_b", "_c", "result", "message", "clientIds", "maxDelay", "id", "cIds", "clients", "c", "resolve", "reject", "client", "delay", "_", "SingleCommunication", "messagePort", "event", "data", "_a", "_b", "type", "message", "transferables", "resolve", "reject", "id", "t", "handle", "result", "promisifyRequest", "request", "resolve", "reject", "createStore", "dbName", "storeName", "dbp", "getDB", "db", "txMode", "callback", "defaultGetStoreFunc", "defaultGetStore", "get", "key", "customStore", "store", "set", "value", "store", "createStore", "ServiceWorkerClients", "_a", "get", "ids", "c", "set", "id", "workers", "swClients", "ServiceWorkerClients", "coms", "ServiceWorkerCommunication", "worker", "id", "port", "SingleCommunication", "event", "cache", "install", "installed", "err", "reg", "sendToWorker", "fromNetworkOrCached", "next", "_a", "stream", "body", "tstream", "writer", "buffer", "response", "toObject", "request", "cached", "headers", "result", "value", "key"]
}
